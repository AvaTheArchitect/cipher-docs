// handlers/music/maestroGuitarModuleBuilderHandler.ts
// üé∏ Maestro.ai Guitar Module Builder Handler - Hybrid Architecture
// Single Command: "Cipher Maestro Builder Maestro Guitar Modules"
// Handles CREATE FILES, UPDATE EXISTING, and MODULE BUILD modes with sophisticated templates

import * as fs from "fs";
import * as path from "path";
import * as vscode from "vscode";

// üß† Dual Brain System Integration
import { BrainConnector } from "../../brain/BrainConnector";
import { getBrainInterface } from "../../shared/utils";

// üõ°Ô∏è File Protection & Index Management
import {
  findMaestroProjectRoot,
  manageIndexFiles,
  protectMaestroGuitarInstallation,
} from "../../shared/indexSyncUtils";

// üéº Production Template System
import {
  generateComponentTemplate,
  generateConfigTemplate,
  generateDataTemplate,
  generateEngineTemplate,
  generateHookTemplate,
  generateParserTemplate,
  generateTypesTemplate,
  generateUtilTemplate,
} from "../../shared/templateGenerators";

// üéµ Music Theory Integration
import {
  calculateFret,
  escapeRegExp,
  getChordFingering,
  inferTimeSignatureFromBeats,
  normalizeTuning,
  noteToFrequency,
  toSVGTabHeader,
} from "../../shared/musicUtils";

// ===== Core Types =====
export interface FileSpec {
  path: string;
  type?: string;
  description?: string;
  componentName?: string;
  features?: string[];
}

export interface UpdateBlock {
  componentName: string;
  description: string;
  features: string[];
  type: string;
}

export interface SpecificationData {
  createFiles?: FileSpec[];
  updateBlocks?: UpdateBlock[]; // ADDED: Support for updating existing files
  modules?: Array<{
    name?: string;
    path?: string;
    description?: string;
    type?: string;
  }>;
  requirements?: string[];
  features?: string[];
  constraints?: string[];
}

export interface BuildResult {
  mode: "create-files" | "build-modules" | "hybrid";
  files: FileSpec[]; // Always provide array, empty if no files
  modules: any[]; // Always provide array, empty if no modules
  updates?: number; // ADDED: Track number of files updated
  estimatedTime: number;
  dependencies: string[];
  success: boolean;
}

// ===== File Processing Strategy =====
type ProcessingOrder = "FIFO" | "LIFO";
const PROCESSING_ORDER: ProcessingOrder = "FIFO";

export class MaestroGuitarModuleBuilder {
  private outputChannel =
    vscode.window.createOutputChannel("Maestro.ai Builder");
  private lastProcessedSpec: string | null = null;

  // ================================================
  // MAIN ENTRY POINT - Single Command Handler
  // ================================================
  public async buildMaestroGuitarModules(
    specPath?: string
  ): Promise<BuildResult> {
    const maestroBridge: any = (BrainConnector as any).getInstance?.() ?? null;

    try {
      const maestroRoot = findMaestroProjectRoot();
      if (!maestroRoot) throw new Error("Maestro root not found");

      // Protection and Brain notification
      protectMaestroGuitarInstallation();
      await maestroBridge?.shareIntelligence?.("maestro_build_start", {
        handler: "MaestroGuitarModuleBuilder",
        timestamp: Date.now(),
        specPath: specPath ?? null,
      });

      // Parse specification from .md file
      const specs = await this.parseSpecification(specPath);
      let result: BuildResult = {
        mode: "create-files",
        files: [],
        modules: [],
        updates: 0,
        estimatedTime: 0,
        dependencies: [],
        success: true,
      };

      // HYBRID EXECUTION: Support multiple operations in sequence
      let operationCount = 0;

      // FIRST: Handle updates to existing files
      if (specs.updateBlocks && specs.updateBlocks.length > 0) {
        const updateCount = await this.executeUpdates(specs, maestroRoot);
        result.updates = updateCount;
        result.mode = "hybrid";
        operationCount++;
      }

      // SECOND: Handle new file creation
      if (specs.createFiles && specs.createFiles.length > 0) {
        const createResult = await this.executeCreateFiles(specs, maestroRoot);
        result.files = createResult.files;
        result.mode = operationCount > 0 ? "hybrid" : "create-files";
        operationCount++;
      }

      // THIRD: Handle module building (fallback when no other operations)
      if (operationCount === 0) {
        result = await this.executeBuildModules(specs, maestroRoot);
      }

      // Display results in webview
      await this.displayBuildResults(result);

      // Move processed spec
      if (this.lastProcessedSpec) {
        await this.moveSpec(this.lastProcessedSpec, "processed");
      }

      // Brain learning
      await this.performBrainLearning("maestro_build_success", true, {
        mode: result.mode,
        filesCreated: result.files?.length ?? 0,
        modulesBuilt: result.modules?.length ?? 0,
        filesUpdated: result.updates ?? 0,
      });

      return result;
    } catch (error) {
      // Error handling and brain learning
      if (this.lastProcessedSpec) {
        try {
          await this.moveSpec(this.lastProcessedSpec, "failed");
        } catch {}
      }

      await this.performBrainLearning("maestro_build_error", false, {
        error: error instanceof Error ? error.message : String(error),
      });

      await maestroBridge?.shareIntelligence?.("maestro_build_error", {
        handler: "MaestroGuitarModuleBuilder",
        timestamp: Date.now(),
        error: error instanceof Error ? error.message : String(error),
      });

      throw error;
    }
  }

  // ================================================
  // SPECIFICATION PARSING - Universal .md Processing
  // ================================================
  private getInputFolders() {
    const maestroRoot = findMaestroProjectRoot();
    if (!maestroRoot) throw new Error("Maestro root not found");
    const inputFolder = path.join(maestroRoot, "maestro-ai-input");
    const processedFolder = path.join(inputFolder, "processed");
    const failedFolder = path.join(inputFolder, "failed");
    return { maestroRoot, inputFolder, processedFolder, failedFolder };
  }

  private findNextSpecification(): string | null {
    const { inputFolder } = this.getInputFolders();
    if (!fs.existsSync(inputFolder)) return null;

    const specs = fs
      .readdirSync(inputFolder)
      .filter((f) => f.toLowerCase().endsWith(".md"))
      .map((f) => {
        const p = path.join(inputFolder, f);
        const st = fs.statSync(p);
        return { path: p, mtimeMs: st.mtimeMs };
      })
      .sort((a, b) =>
        PROCESSING_ORDER === "FIFO"
          ? a.mtimeMs - b.mtimeMs
          : b.mtimeMs - a.mtimeMs
      );

    return specs.length ? specs[0].path : null;
  }

  private async parseSpecification(
    specPath?: string
  ): Promise<SpecificationData> {
    let mdPath = specPath;
    if (!mdPath) {
      mdPath = this.findNextSpecification() ?? undefined;
    }

    if (!mdPath || !fs.existsSync(mdPath)) {
      return {
        createFiles: [],
        updateBlocks: [],
        modules: [],
        requirements: [],
        features: [],
        constraints: [],
      };
    }

    this.lastProcessedSpec = mdPath;
    const content = await fs.promises.readFile(mdPath, "utf8");

    return this.parseMdContent(content);
  }

  private parseMdContent(content: string): SpecificationData {
    const getSection = (title: string): string => {
      const regex = new RegExp(
        `(^|\\n)##\\s*${escapeRegExp(title)}:?\\s*\\n([\\s\\S]*?)(?=\\n##\\s|$)`,
        "i"
      );
      const match = content.match(regex);
      const result = match ? match[2].trim() : "";
      console.log(
        `üìã Searching for section: "${title}", found ${result.length} characters`
      );
      return result;
    };

    const parseLines = (block: string): string[] =>
      (block.match(/^- .+$/gim) || block.split("\n"))
        .map((l) => l.replace(/^\-\s*/, "").trim())
        .filter(Boolean);

    const createFilesBlock = getSection("Create Files");
    const modulesBlock = getSection("Modules") || getSection("Components");
    const requirementsBlock = getSection("Requirements");
    const featuresBlock = getSection("Features") || getSection("Update");
    const constraintsBlock = getSection("Constraints") || getSection("Notes");

    console.log(`üìã Section analysis:`);
    console.log(`üìã - Create Files section: ${createFilesBlock.length} chars`);
    console.log(`üìã - Modules section: ${modulesBlock.length} chars`);
    console.log(`üìã - Requirements section: ${requirementsBlock.length} chars`);

    // DEBUG: Show all sections found in the markdown
    const allSections = content.match(/##\s*([^:\n]+):?\s*\n/gi) || [];
    console.log(
      `üìã All sections found in markdown: ${allSections.map((s) => s.trim()).join(", ")}`
    );

    // ADDED: Parse update sections like "## Update: TestGuitarComponent"
    const updateBlocks: UpdateBlock[] = [];
    const updatePattern = /##?\s*Update:\s*(.+?)\n([\s\S]*?)(?=\n##|\n#|$)/gi;
    let updateMatch;

    console.log(`üìã Parsing markdown content for update blocks...`);

    while ((updateMatch = updatePattern.exec(content)) !== null) {
      const componentName = updateMatch[1].trim();
      const description = updateMatch[2].trim();

      console.log(`üìã Found update block: ${componentName}`);

      updateBlocks.push({
        componentName,
        description,
        features: this.extractFeaturesFromDescription(description),
        type: "update",
      });
    }

    console.log(`üìã Total update blocks parsed: ${updateBlocks.length}`);

    // Parse create files: "- path - description"
    const createFiles: FileSpec[] = [];
    const fileLines = (createFilesBlock.match(/^- .+$/gim) || []).map((l) =>
      l.replace(/^\-\s*/, "")
    );

    console.log(
      `üìã Parsing create files block, found ${fileLines.length} lines`
    );

    for (const line of fileLines) {
      const separatorIndex = line.indexOf(" - ");
      const filePath =
        separatorIndex >= 0
          ? line.slice(0, separatorIndex).trim()
          : line.trim();
      const description =
        separatorIndex >= 0 ? line.slice(separatorIndex + 3).trim() : "";

      if (filePath) {
        console.log(`üìã Adding create file: ${filePath}`);
        createFiles.push({
          path: filePath,
          type: this.detectFileType(filePath),
          description,
          componentName: this.extractComponentName(filePath),
          features: this.detectFeatures(filePath, description),
        });
      }
    }

    console.log(`üìã Total create files parsed: ${createFiles.length}`);

    // Parse modules
    const modules: any[] = [];
    const moduleLines = parseLines(modulesBlock);
    for (const line of moduleLines) {
      const separatorIndex = line.indexOf(" - ");
      const name =
        separatorIndex >= 0
          ? line.slice(0, separatorIndex).trim()
          : line.trim();
      const description =
        separatorIndex >= 0 ? line.slice(separatorIndex + 3).trim() : "";

      if (name) {
        modules.push({
          name,
          description,
          type: this.detectFileType(name),
          path: this.generateModulePath(name),
        });
      }
    }

    return {
      createFiles,
      updateBlocks, // ADDED: Include parsed update blocks
      modules,
      requirements: parseLines(requirementsBlock),
      features: parseLines(featuresBlock),
      constraints: parseLines(constraintsBlock),
    };
  }

  // ADDED: Extract features from update description
  private extractFeaturesFromDescription(description: string): string[] {
    const features: string[] = [];
    const lines = description.split("\n");

    for (const line of lines) {
      const trimmedLine = line.trim();
      if (trimmedLine.startsWith("-") || trimmedLine.startsWith("*")) {
        const feature = trimmedLine.replace(/^[-*]\s*/, "").trim();
        if (feature.length > 0) {
          features.push(feature);
        }
      }
    }
    return features;
  }

  // ================================================
  // UPDATE EXISTING FILES MODE - NEW FUNCTIONALITY
  // ================================================
  private async executeUpdates(
    specs: SpecificationData,
    maestroRoot: string
  ): Promise<number> {
    if (!specs.updateBlocks || specs.updateBlocks.length === 0) {
      console.log(`üîÑ No update blocks to process`);
      return 0;
    }

    console.log(`üîÑ Processing ${specs.updateBlocks.length} update blocks`);
    let updatedCount = 0;

    for (const updateBlock of specs.updateBlocks) {
      try {
        console.log(`üîÑ Processing update for: ${updateBlock.componentName}`);
        const targetFiles = await this.findExistingFiles(
          updateBlock.componentName,
          maestroRoot
        );

        console.log(
          `üîÑ Found ${targetFiles.length} files to update for ${updateBlock.componentName}`
        );
        if (targetFiles.length > 0) {
          console.log(`üîÑ Target files: ${targetFiles.join(", ")}`);
        }

        for (const targetFile of targetFiles) {
          console.log(`üîÑ Updating file: ${targetFile}`);
          await this.updateExistingFile(targetFile, updateBlock, maestroRoot);
          this.outputChannel.appendLine(
            `‚úÖ Updated: ${path.basename(targetFile)}`
          );
          updatedCount++;
        }

        if (targetFiles.length === 0) {
          console.log(
            `‚ö†Ô∏è No existing files found for: ${updateBlock.componentName}`
          );
          this.outputChannel.appendLine(
            `‚ö†Ô∏è No existing files found for: ${updateBlock.componentName}`
          );
        }
      } catch (error) {
        console.log(`‚ùå Error updating ${updateBlock.componentName}: ${error}`);
        this.outputChannel.appendLine(
          `‚ùå Failed to update ${updateBlock.componentName}: ${error}`
        );
      }
    }

    console.log(`üîÑ Update process complete. Updated ${updatedCount} files.`);
    return updatedCount;
  }

  private async findExistingFiles(
    componentName: string,
    maestroRoot: string
  ): Promise<string[]> {
    const searchPaths = [
      "src/components",
      "src/modules",
      "src/hooks",
      "src/utils",
      "src/engines",
      "src/parsers",
      "src/notation", // ADD: For notation parsers
      "src/types", // ADD: For type files
      "src/data", // ADD: For data files
    ];

    console.log(`üîç Searching for component: ${componentName}`);
    console.log(`üîç Search paths: ${searchPaths.join(", ")}`);

    const existingFiles: string[] = [];

    for (const searchPath of searchPaths) {
      const fullSearchPath = path.join(maestroRoot, searchPath);
      console.log(`üîç Checking path: ${fullSearchPath}`);

      if (fs.existsSync(fullSearchPath)) {
        console.log(`üîç Path exists, searching recursively...`);
        const found = await this.searchDirectoryRecursive(
          fullSearchPath,
          componentName
        );
        console.log(
          `üîç Found ${found.length} files in ${searchPath}: ${found.map((f) => path.basename(f)).join(", ")}`
        );
        existingFiles.push(...found);
      } else {
        console.log(`üîç Path does not exist: ${fullSearchPath}`);
      }
    }

    console.log(
      `üîç Total files found for ${componentName}: ${existingFiles.length}`
    );
    return existingFiles;
  }

  private async searchDirectoryRecursive(
    dir: string,
    componentName: string
  ): Promise<string[]> {
    const files: string[] = [];

    try {
      const items = fs.readdirSync(dir);

      for (const item of items) {
        const fullPath = path.join(dir, item);
        const stat = fs.statSync(fullPath);

        if (stat.isDirectory()) {
          const subFiles = await this.searchDirectoryRecursive(
            fullPath,
            componentName
          );
          files.push(...subFiles);
        } else if (
          (item.includes(componentName) ||
            item === `${componentName}.tsx` ||
            item === `${componentName}.ts`) &&
          (item.endsWith(".tsx") || item.endsWith(".ts")) &&
          !item.includes(".test.") &&
          !item.includes(".spec.")
        ) {
          files.push(fullPath);
        }
      }
    } catch (error) {
      // Directory access error - skip silently
    }

    return files;
  }

  private async updateExistingFile(
    filePath: string,
    updateBlock: UpdateBlock,
    maestroRoot: string
  ): Promise<void> {
    // ADDED: Explicit backup creation before modification
    console.log(
      `üîÑ UPDATE MODE: Backing up existing ${path.basename(filePath)}`
    );

    try {
      const { protectFileModification } = await import(
        "../../shared/indexSyncUtils"
      );
      const backupSuccess = protectFileModification(filePath);

      if (backupSuccess) {
        console.log(`üíæ Backup created for ${path.basename(filePath)}`);
        this.outputChannel.appendLine(
          `üíæ Backup created for ${path.basename(filePath)}`
        );
      } else {
        console.warn(
          `‚ö†Ô∏è Backup failed for ${path.basename(filePath)}, proceeding anyway`
        );
        this.outputChannel.appendLine(
          `‚ö†Ô∏è Backup failed for ${path.basename(filePath)}`
        );
      }
    } catch (error) {
      console.error(`‚ùå Backup error for ${path.basename(filePath)}:`, error);
      this.outputChannel.appendLine(
        `‚ùå Backup error for ${path.basename(filePath)}: ${error}`
      );
    }

    // Read existing content
    const existingContent = await fs.promises.readFile(filePath, "utf8");

    // Create a mock module for the existing merge logic
    const mockModule = {
      name: updateBlock.componentName,
      description: updateBlock.description,
      isUpdate: true,
      features: updateBlock.features,
    };

    // Use existing merge logic
    const enhancedContent = await this.mergeUpdateWithExisting(
      existingContent,
      "", // template not needed for updates
      mockModule
    );

    // Write updated content
    await fs.promises.writeFile(filePath, enhancedContent, "utf8");

    // Update index files using shared utility
    const dirPath = path.dirname(filePath);
    manageIndexFiles(dirPath);

    // ADDED: If this is in a parsers directory, create proper index.ts
    if (dirPath.includes("parsers")) {
      await this.createParsersIndex(dirPath);
    }
  }

  private async createParsersIndex(parsersDir: string): Promise<void> {
    const indexPath = path.join(parsersDir, "index.ts");

    // Get all .ts files in the parsers directory (except index.ts)
    const files = fs
      .readdirSync(parsersDir)
      .filter((file) => file.endsWith(".ts") && file !== "index.ts")
      .map((file) => path.basename(file, ".ts"));

    if (files.length === 0) return;

    console.log(
      `üîß Creating proper parsers index with exports: ${files.join(", ")}`
    );

    const exportStatements = files
      .map(
        (fileName) =>
          `export { default as ${fileName}, ${fileName} } from './${fileName}';`
      )
      .join("\n");

    const indexContent = `/**
 * Notation Parsers Index
 * Exports all notation parsing modules
 */

${exportStatements}

// Re-export all parsers as a single object
export const notationParsers = {
  ${files.join(",\n  ")}
};

export default notationParsers;
`;

    await fs.promises.writeFile(indexPath, indexContent, "utf8");
    console.log(`üîß Updated parsers index.ts with ${files.length} exports`);
  }

  // Enhanced merge logic for updates
  private async mergeUpdateWithExisting(
    existingContent: string,
    template: string,
    module: any
  ): Promise<string> {
    // If it's an update, enhance the existing content
    if (module.isUpdate) {
      return this.enhanceExistingContent(existingContent, module);
    }

    // Otherwise use template
    return template;
  }

  private enhanceExistingContent(existingContent: string, module: any): string {
    console.log(`üîß Enhancing content for: ${module.name}`);
    console.log(`üîß Original content length: ${existingContent.length} chars`);

    // Handle module exports (like your parser stubs)
    if (
      existingContent.includes("export const") &&
      existingContent.includes("= {")
    ) {
      return this.enhanceModuleExport(existingContent, module);
    }

    // Handle React components
    if (
      existingContent.includes("React") ||
      existingContent.includes("function") ||
      existingContent.includes("const")
    ) {
      return this.enhanceReactComponent(existingContent, module);
    }

    // Fallback: replace entire stub with full implementation
    return this.generateFullImplementation(module);
  }

  private enhanceModuleExport(existingContent: string, module: any): string {
    console.log(`üîß Enhancing module export for: ${module.name}`);

    // For parser modules, generate comprehensive implementation
    const newImplementation = this.generateParserImplementation(module);

    console.log(
      `üîß Generated new implementation length: ${newImplementation.length} chars`
    );
    return newImplementation;
  }

  private generateParserImplementation(module: any): string {
    const name = module.name;
    const description = module.description || "";

    if (name.includes("staff")) {
      return this.generateStaffNotationParser();
    } else if (name.includes("chord")) {
      return this.generateChordSymbolParser();
    } else if (name.includes("technique")) {
      return this.generateTechniqueParser();
    } else if (name.includes("rhythm")) {
      return this.generateRhythmParser();
    }

    return this.generateGenericParser(name, description);
  }

  private generateStaffNotationParser(): string {
    return `/**
 * Staff Notation Parser - Complete Implementation
 * Parses treble/bass clefs, key signatures, time signatures, and notes
 */

export interface StaffNote {
  pitch: string;
  octave: number;
  duration: string;
  accidental?: 'sharp' | 'flat' | 'natural';
  timeMs: number;
}

export interface KeySignature {
  key: string;
  mode: 'major' | 'minor';
  sharps: number;
  flats: number;
}

export interface TimeSignature {
  beats: number;
  beatType: number;
  compound: boolean;
}

export const staffNotationParser = {
  info: 'Complete staff notation parser with clef detection and music theory',
  
  initialize: () => {
    console.log('Advanced staff notation parser initialized');
  },

  parseClef: (notation: string): 'treble' | 'bass' | 'alto' | 'tenor' => {
    if (notation.includes('ùÑû') || notation.includes('treble')) return 'treble';
    if (notation.includes('ùÑ¢') || notation.includes('bass')) return 'bass';
    if (notation.includes('ùÑ°') || notation.includes('alto')) return 'alto';
    return 'treble'; // default
  },

  parseKeySignature: (notation: string): KeySignature => {
    const sharpCount = (notation.match(/‚ôØ/g) || []).length;
    const flatCount = (notation.match(/‚ô≠/g) || []).length;
    
    const keyMap = {
      0: 'C', 1: 'G', 2: 'D', 3: 'A', 4: 'E', 5: 'B', 6: 'F#'
    };
    
    return {
      key: keyMap[sharpCount as keyof typeof keyMap] || 'C',
      mode: 'major',
      sharps: sharpCount,
      flats: flatCount
    };
  },

  parseTimeSignature: (notation: string): TimeSignature => {
    const match = notation.match(/(\\d+)\\/(\\d+)/);
    if (!match) return { beats: 4, beatType: 4, compound: false };
    
    const beats = parseInt(match[1]);
    const beatType = parseInt(match[2]);
    
    return {
      beats,
      beatType,
      compound: beats % 3 === 0 && beats > 3
    };
  },

  parseNotes: (notation: string): StaffNote[] => {
    const notes: StaffNote[] = [];
    const notePattern = /([CDEFGAB])([#b]?)([0-9])\\s*(w|h|q|e|s)/g;
    let match;
    let timeMs = 0;

    while ((match = notePattern.exec(notation)) !== null) {
      const [, pitch, accidental, octave, duration] = match;
      
      notes.push({
        pitch,
        octave: parseInt(octave),
        duration,
        accidental: accidental === '#' ? 'sharp' : accidental === 'b' ? 'flat' : undefined,
        timeMs
      });
      
      // Approximate duration in ms
      const durationMs = duration === 'w' ? 4000 : duration === 'h' ? 2000 : 
                        duration === 'q' ? 1000 : duration === 'e' ? 500 : 250;
      timeMs += durationMs;
    }
    
    return notes;
  },

  parseFull: (notation: string) => {
    const clef = staffNotationParser.parseClef(notation);
    const keySignature = staffNotationParser.parseKeySignature(notation);
    const timeSignature = staffNotationParser.parseTimeSignature(notation);
    const notes = staffNotationParser.parseNotes(notation);
    
    return {
      clef,
      keySignature,
      timeSignature,
      notes,
      measures: Math.ceil(notes.length / timeSignature.beats)
    };
  }
};

export default staffNotationParser;`;
  }

  private generateChordSymbolParser(): string {
    return `/**
 * Chord Symbol Parser - Complete Implementation
 * Parses Rock, Metal, Country, Blues, and Contemporary Christian chords
 */

export interface ChordSymbol {
  root: string;
  quality: string;
  extensions: string[];
  bass?: string;
  position: number;
  romanNumeral?: string;
}

export const chordSymbolParser = {
  info: 'Advanced chord parser for Rock, Metal, Country, Blues, and Contemporary Christian music',
  
  initialize: () => {
    console.log('Rock/Metal/Country/Blues/Contemporary Christian chord parser initialized');
  },

  parseChord: (symbol: string): ChordSymbol => {
    const chordRegex = /^([A-G][#b]?)(.*?)(?:\\/([A-G][#b]?))?$/;
    const match = symbol.match(chordRegex);
    
    if (!match) {
      return { root: 'C', quality: 'major', extensions: [], position: 0 };
    }
    
    const [, root, qualityExt, bass] = match;
    const extensions: string[] = [];
    let quality = 'major';
    
    // Parse quality and extensions - focus on Rock/Metal/Country/Blues/Contemporary Christian
    if (qualityExt.includes('m') && !qualityExt.includes('maj')) quality = 'minor';
    if (qualityExt.includes('dim')) quality = 'diminished';
    if (qualityExt.includes('aug') || qualityExt.includes('+')) quality = 'augmented';
    if (qualityExt.includes('sus2')) { quality = 'suspended'; extensions.push('sus2'); }
    if (qualityExt.includes('sus4') || qualityExt.includes('sus')) { quality = 'suspended'; extensions.push('sus4'); }
    if (qualityExt.includes('7')) extensions.push('7');
    if (qualityExt.includes('add9') || qualityExt.includes('add2')) extensions.push('add9');
    if (qualityExt.includes('maj7')) extensions.push('maj7');
    
    return {
      root,
      quality,
      extensions,
      bass,
      position: 0
    };
  },

  analyzeProgression: (chords: string[]): string[] => {
    const romanNumerals = ['I', 'ii', 'iii', 'IV', 'V', 'vi', 'vii¬∞'];
    const keyOfC = ['C', 'Dm', 'Em', 'F', 'G', 'Am', 'Bdim'];
    
    return chords.map(chord => {
      const parsed = chordSymbolParser.parseChord(chord);
      const index = keyOfC.findIndex(c => c.startsWith(parsed.root));
      return index >= 0 ? romanNumerals[index] : '?';
    });
  },

  detectCommonProgressions: (chords: string[]): string[] => {
    const progression = chordSymbolParser.analyzeProgression(chords);
    const progressionStr = progression.join('-');
    
    const common = [
      { pattern: 'I-V-vi-IV', name: 'Pop/Contemporary Christian Progression' },
      { pattern: 'vi-IV-I-V', name: 'Country/Rock Progression' },
      { pattern: 'I-IV-V-I', name: 'Classic Blues/Rock' },
      { pattern: 'i-VII-VI-VII', name: 'Metal/Rock Progression' },
      { pattern: 'I-vi-ii-V', name: 'Contemporary Worship' },
      { pattern: 'i-iv-V-i', name: 'Minor Blues' }
    ];
    
    return common
      .filter(c => progressionStr.includes(c.pattern))
      .map(c => c.name);
  },

  generateChordTones: (chord: string): string[] => {
    const parsed = chordSymbolParser.parseChord(chord);
    const chromaticScale = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    const rootIndex = chromaticScale.indexOf(parsed.root);
    
    const intervals = [0, 4, 7]; // Major triad intervals
    if (parsed.quality === 'minor') intervals[1] = 3; // Flat 3rd for minor
    if (parsed.quality === 'diminished') { intervals[1] = 3; intervals[2] = 6; }
    if (parsed.extensions.includes('7')) intervals.push(10); // Dominant 7th
    if (parsed.extensions.includes('maj7')) intervals.push(11); // Major 7th
    if (parsed.extensions.includes('sus4')) intervals[1] = 5; // Perfect 4th replaces 3rd
    if (parsed.extensions.includes('sus2')) intervals[1] = 2; // Major 2nd replaces 3rd
    
    return intervals.map(interval => 
      chromaticScale[(rootIndex + interval) % 12]
    );
  }
};

export default chordSymbolParser;`;
  }

  private generateTechniqueParser(): string {
    return `/**
 * Guitar Technique Parser - Complete Implementation  
 * Parses palm muting, vibrato, bends, hammer-ons, pull-offs, slides
 */

export interface GuitarTechnique {
  type: string;
  startFret?: number;
  endFret?: number;
  intensity?: number;
  symbol: string;
  timeMs: number;
}

export const techniqueParser = {
  info: 'Complete guitar technique parser for all standard notation symbols',
  
  initialize: () => {
    console.log('Advanced guitar technique parser initialized');
  },

  parsePalmMuting: (notation: string): GuitarTechnique[] => {
    const pmPattern = /P\\.?M\\.?|PM|\\.\\.\\./g;
    const techniques: GuitarTechnique[] = [];
    let match;
    
    while ((match = pmPattern.exec(notation)) !== null) {
      techniques.push({
        type: 'palm-mute',
        symbol: match[0],
        timeMs: match.index * 100 // approximate timing
      });
    }
    
    return techniques;
  },

  parseVibrato: (notation: string): GuitarTechnique[] => {
    const vibratoPattern = /~{2,}|‚âà/g;
    const techniques: GuitarTechnique[] = [];
    let match;
    
    while ((match = vibratoPattern.exec(notation)) !== null) {
      techniques.push({
        type: 'vibrato',
        intensity: match[0].length,
        symbol: match[0],
        timeMs: match.index * 100
      });
    }
    
    return techniques;
  },

  parseBends: (notation: string): GuitarTechnique[] => {
    const bendPattern = /(\\d+)b(\\d+)|bend|\\^/g;
    const techniques: GuitarTechnique[] = [];
    let match;
    
    while ((match = bendPattern.exec(notation)) !== null) {
      if (match[1] && match[2]) {
        techniques.push({
          type: 'bend',
          startFret: parseInt(match[1]),
          endFret: parseInt(match[2]),
          symbol: match[0],
          timeMs: match.index * 100
        });
      } else {
        techniques.push({
          type: 'bend',
          symbol: match[0],
          timeMs: match.index * 100
        });
      }
    }
    
    return techniques;
  },

  parseSlurs: (notation: string): GuitarTechnique[] => {
    const hammerPattern = /(\\d+)h(\\d+)/g;
    const pullPattern = /(\\d+)p(\\d+)/g;
    const techniques: GuitarTechnique[] = [];
    let match;
    
    while ((match = hammerPattern.exec(notation)) !== null) {
      techniques.push({
        type: 'hammer-on',
        startFret: parseInt(match[1]),
        endFret: parseInt(match[2]),
        symbol: match[0],
        timeMs: match.index * 100
      });
    }
    
    while ((match = pullPattern.exec(notation)) !== null) {
      techniques.push({
        type: 'pull-off',
        startFret: parseInt(match[1]),
        endFret: parseInt(match[2]),
        symbol: match[0],
        timeMs: match.index * 100
      });
    }
    
    return techniques;
  },

  parseSlides: (notation: string): GuitarTechnique[] => {
    const slidePattern = /(\\d+)[\\/\\\\](\\d+)/g;
    const techniques: GuitarTechnique[] = [];
    let match;
    
    while ((match = slidePattern.exec(notation)) !== null) {
      techniques.push({
        type: 'slide',
        startFret: parseInt(match[1]),
        endFret: parseInt(match[2]),
        symbol: match[0],
        timeMs: match.index * 100
      });
    }
    
    return techniques;
  },

  parseAll: (notation: string): GuitarTechnique[] => {
    const allTechniques = [
      ...techniqueParser.parsePalmMuting(notation),
      ...techniqueParser.parseVibrato(notation),
      ...techniqueParser.parseBends(notation),
      ...techniqueParser.parseSlurs(notation),
      ...techniqueParser.parseSlides(notation)
    ];
    
    return allTechniques.sort((a, b) => a.timeMs - b.timeMs);
  }
};

export default techniqueParser;`;
  }

  private generateRhythmParser(): string {
    return `/**
 * Rhythm Notation Parser - Complete Implementation
 * Handles time signatures, tuplets, rests, and complex subdivisions
 */

export interface RhythmNote {
  duration: string;
  dotted: boolean;
  tuplet?: number;
  rest: boolean;
  timeMs: number;
  beatPosition: number;
}

export const rhythmNotationParser = {
  info: 'Complete rhythm parser with tuplets and complex time signatures',
  
  initialize: () => {
    console.log('Advanced rhythm notation parser initialized');
  },

  parseDurations: (notation: string): RhythmNote[] => {
    const durationPattern = /([whqes])(\\.|t3|t5|t7)?/g;
    const notes: RhythmNote[] = [];
    let match;
    let timeMs = 0;
    
    while ((match = durationPattern.exec(notation)) !== null) {
      const [, duration, modifier] = match;
      
      let baseDuration = 0;
      switch (duration) {
        case 'w': baseDuration = 4000; break; // whole
        case 'h': baseDuration = 2000; break; // half  
        case 'q': baseDuration = 1000; break; // quarter
        case 'e': baseDuration = 500; break;  // eighth
        case 's': baseDuration = 250; break;  // sixteenth
      }
      
      if (modifier === '.') baseDuration *= 1.5; // dotted
      
      let tuplet;
      if (modifier === 't3') { baseDuration *= 2/3; tuplet = 3; }
      if (modifier === 't5') { baseDuration *= 4/5; tuplet = 5; }
      if (modifier === 't7') { baseDuration *= 6/7; tuplet = 7; }
      
      notes.push({
        duration,
        dotted: modifier === '.',
        tuplet,
        rest: false,
        timeMs,
        beatPosition: timeMs / 1000
      });
      
      timeMs += baseDuration;
    }
    
    return notes;
  },

  parseRests: (notation: string): RhythmNote[] => {
    const restPattern = /r([whqes])(\\.|t3|t5|t7)?/g;
    const rests: RhythmNote[] = [];
    let match;
    let timeMs = 0;
    
    while ((match = restPattern.exec(notation)) !== null) {
      const [, duration, modifier] = match;
      
      let baseDuration = 0;
      switch (duration) {
        case 'w': baseDuration = 4000; break;
        case 'h': baseDuration = 2000; break;
        case 'q': baseDuration = 1000; break;
        case 'e': baseDuration = 500; break;
        case 's': baseDuration = 250; break;
      }
      
      if (modifier === '.') baseDuration *= 1.5;
      
      rests.push({
        duration,
        dotted: modifier === '.',
        rest: true,
        timeMs,
        beatPosition: timeMs / 1000
      });
      
      timeMs += baseDuration;
    }
    
    return rests;
  },

  analyzeMeter: (notes: RhythmNote[], timeSignature: [number, number] = [4, 4]): any => {
    const [beats, beatType] = timeSignature;
    const measureDuration = (beats * 4000) / beatType;
    
    const measures = [];
    let currentMeasure: RhythmNote[] = [];
    let measureTime = 0;
    
    for (const note of notes) {
      if (measureTime >= measureDuration) {
        measures.push(currentMeasure);
        currentMeasure = [];
        measureTime = 0;
      }
      
      currentMeasure.push(note);
      measureTime += note.timeMs;
    }
    
    if (currentMeasure.length > 0) {
      measures.push(currentMeasure);
    }
    
    return {
      measures,
      timeSignature,
      totalDuration: notes[notes.length - 1]?.timeMs || 0
    };
  },

  detectSyncopation: (notes: RhythmNote[], timeSignature: [number, number] = [4, 4]): boolean[] => {
    const [beats] = timeSignature;
    const strongBeats = Array.from({ length: beats }, (_, i) => i);
    
    return notes.map(note => {
      const beat = Math.floor(note.beatPosition) % beats;
      return !strongBeats.includes(beat) && !note.rest;
    });
  }
};

export default rhythmNotationParser;`;
  }

  private generateGenericParser(name: string, description: string): string {
    const className = this.extractComponentName(name);

    return `/**
 * ${className} - Enhanced Implementation
 * ${description}
 */

export interface ParseResult<T = any> {
  ok: boolean;
  errors: string[];
  warnings: string[];
  data?: T;
  metadata?: Record<string, any>;
}

export interface ParsedData {
  lineCount: number;
  content: string[];
  length: number;
  hasContent: boolean;
  jsonData?: any; // Optional JSON data if input is JSON
}

export function ${className}Parser(input: string): ParseResult<ParsedData> {
  const result: ParseResult<ParsedData> = {
    ok: false,
    errors: [],
    warnings: [],
    data: undefined,
    metadata: {}
  };

  try {
    if (!input || !input.trim()) {
      result.errors.push('Empty input provided');
      return result;
    }

    const lines = input.split('\\n').filter(line => line.trim());
    const parsed: ParsedData = {
      lineCount: lines.length,
      content: lines,
      length: input.length,
      hasContent: lines.length > 0
    };

    if (input.trim().startsWith('{') || input.trim().startsWith('[')) {
      try {
        parsed.jsonData = JSON.parse(input);
        result.metadata!.format = 'json'; // Non-null assertion since we initialize it
      } catch {
        result.warnings.push('Input looks like JSON but failed to parse');
      }
    }

    result.data = parsed;
    result.ok = true;
    
  } catch (error) {
    result.errors.push(error instanceof Error ? error.message : String(error));
  }

  return result;
}

export const ${name} = {
  info: '${description}',
  
  initialize: () => {
    console.log('${name} enhanced parser initialized');
  },

  parse: ${className}Parser,

  validate: (data: ParsedData): boolean => {
    return data && typeof data === 'object' && data.hasContent;
  },

  transform: (data: ParsedData): ParsedData & { processed: boolean; version: string } => {
    return {
      ...data,
      processed: true,
      version: '1.0'
    };
  }
};

export default ${name};`;
  }

  private enhanceReactComponent(existingContent: string, module: any): string {
    // Keep existing React component enhancement logic
    return existingContent + "\n// Enhanced with new functionality\n";
  }

  private generateFullImplementation(module: any): string {
    return `// Full implementation for ${module.name}\nexport default {};\n`;
  }

  private generateNewFunctionality(
    description: string,
    features: string[]
  ): string {
    const functionality: string[] = [];

    // Parse description for specific functionality to add
    if (description.toLowerCase().includes("chord progression")) {
      functionality.push(`
  const generateChordProgression = useCallback((key: string) => {
    const progressions = {
      'C': ['C', 'Am', 'F', 'G'],
      'G': ['G', 'Em', 'C', 'D'],
      'D': ['D', 'Bm', 'G', 'A']
    };
    return progressions[key as keyof typeof progressions] || progressions['C'];
  }, []);`);
    }

    if (description.toLowerCase().includes("audio sync")) {
      functionality.push(`
  const audioSync = useAutoScroll({
    velocity: 0.5,
    easing: true,
    boundaries: { minY: 0, maxY: 1000 }
  });`);
    }

    if (description.toLowerCase().includes("notation parsing")) {
      functionality.push(`
  const parseNotation = useCallback((input: string) => {
    // Enhanced notation parsing logic
    return parseComplexNotation(input);
  }, []);`);
    }

    // Add feature-based functionality
    for (const feature of features) {
      if (feature.toLowerCase().includes("scroll")) {
        functionality.push(`
  // Enhanced scrolling capability
  const scrollBehavior = useEnhancedScroll();`);
      }

      if (feature.toLowerCase().includes("audio")) {
        functionality.push(`
  // Audio integration
  const audioEngine = useAudioEngine();`);
      }
    }

    return functionality.join("\n");
  }

  // ================================================
  // CREATE FILES MODE - Sophisticated File Generation
  // ================================================
  private async executeCreateFiles(
    specs: SpecificationData,
    maestroRoot: string
  ): Promise<BuildResult> {
    const files = specs.createFiles!;

    // Sort by dependency order
    const dependencyOrder = [
      "types",
      "data",
      "util",
      "hook",
      "component",
      "engine",
      "parser",
    ];
    files.sort((a, b) => {
      const aIndex = dependencyOrder.indexOf(a.type || "component");
      const bIndex = dependencyOrder.indexOf(b.type || "component");
      return aIndex - bIndex;
    });

    const createdFiles: FileSpec[] = [];

    for (const file of files) {
      try {
        const absPath = path.join(maestroRoot, file.path);
        await fs.promises.mkdir(path.dirname(absPath), { recursive: true });

        const content = this.generateSophisticatedContent(file, specs);
        await fs.promises.writeFile(absPath, content, "utf8");

        // Update index files
        manageIndexFiles(path.dirname(absPath));

        createdFiles.push(file);
        this.outputChannel.appendLine(`‚úÖ Created: ${file.path}`);
      } catch (error) {
        this.outputChannel.appendLine(
          `‚ùå Failed to create ${file.path}: ${error}`
        );
      }
    }

    return {
      mode: "create-files",
      files: createdFiles,
      modules: [], // Empty array for backward compatibility
      estimatedTime: Math.ceil(createdFiles.length * 0.5),
      dependencies: this.analyzeDependencies(createdFiles),
      success: true,
    };
  }

  // ================================================
  // MODULE BUILD MODE - Traditional Module Creation
  // ================================================
  private async executeBuildModules(
    specs: SpecificationData,
    maestroRoot: string
  ): Promise<BuildResult> {
    const modules = specs.modules || [];
    const builtModules: any[] = [];

    for (const module of modules) {
      try {
        const absPath = path.join(
          maestroRoot,
          module.path || this.generateModulePath(module.name!)
        );
        await fs.promises.mkdir(path.dirname(absPath), { recursive: true });

        const fileSpec: FileSpec = {
          path: module.path || this.generateModulePath(module.name!),
          type: module.type || this.detectFileType(module.name!),
          description: module.description || "",
          componentName: module.name,
        };

        const content = this.generateSophisticatedContent(fileSpec, specs);
        await fs.promises.writeFile(absPath, content, "utf8");

        manageIndexFiles(path.dirname(absPath));

        builtModules.push(module);
        this.outputChannel.appendLine(`‚úÖ Built: ${module.name}`);
      } catch (error) {
        this.outputChannel.appendLine(
          `‚ùå Failed to build ${module.name}: ${error}`
        );
      }
    }

    return {
      mode: "build-modules",
      files: [], // Empty array for backward compatibility
      modules: builtModules,
      estimatedTime: Math.ceil(builtModules.length * 0.5),
      dependencies: this.analyzeDependencies(
        builtModules.map((m) => ({ type: m.type }))
      ),
      success: true,
    };
  }

  // ================================================
  // SOPHISTICATED CONTENT GENERATION
  // ================================================
  private generateSophisticatedContent(
    file: FileSpec,
    context: SpecificationData
  ): string {
    const meta = {
      path: file.path,
      description: file.description || "",
      componentName: file.componentName,
      music: {
        normalizeTuning,
        inferTimeSignatureFromBeats,
        toSVGTabHeader,
        noteToFrequency,
        calculateFret,
        getChordFingering,
      },
    };

    switch (file.type) {
      case "test":
        return this.generateTestFile(file, meta, context);
      case "component":
        return this.generateAdvancedComponent(file, meta, context);
      case "hook":
        return this.generateAdvancedHook(file, meta, context);
      case "engine":
        return this.generateAdvancedEngine(file, meta, context);
      case "parser":
        return this.generateAdvancedParser(file, meta, context);
      case "util":
        return this.generateAdvancedUtil(file, meta, context);
      case "types":
        return this.generateAdvancedTypes(file, meta, context);
      case "data":
        return generateDataTemplate(meta);
      case "config":
        return generateConfigTemplate(meta);
      default:
        return generateComponentTemplate(meta);
    }
  }

  private generateTestFile(
    file: FileSpec,
    meta: any,
    context: SpecificationData
  ): string {
    const componentName =
      meta.componentName || this.extractComponentName(file.path);
    const isComponent = file.path.includes(".tsx");
    const isHook = /hook|use/i.test(file.path);

    if (isComponent) {
      return this.generateComponentTest(componentName, file, meta);
    } else if (isHook) {
      return this.generateHookTest(componentName, file, meta);
    } else {
      return this.generateUtilTest(componentName, file, meta);
    }
  }

  private generateComponentTest(
    componentName: string,
    file: FileSpec,
    meta: any
  ): string {
    const sourceFile = file.path.replace(/\.test\.tsx$/, ".tsx");
    const relativePath = "./" + path.basename(sourceFile);

    return `/**
 * ${componentName} Component Tests
 * Comprehensive testing including edge cases and performance
 */
import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { act, renderHook } from '@testing-library/react';
import '@testing-library/jest-dom';
import ${componentName} from '${relativePath}';

// Mock performance.now for animation tests
const mockPerformanceNow = jest.fn();
Object.defineProperty(window, 'performance', {
  value: { now: mockPerformanceNow },
  writable: true
});

// Mock requestAnimationFrame
const mockRequestAnimationFrame = jest.fn();
Object.defineProperty(window, 'requestAnimationFrame', {
  value: mockRequestAnimationFrame,
  writable: true
});

describe('${componentName}', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    mockPerformanceNow.mockReturnValue(0);
    mockRequestAnimationFrame.mockImplementation(cb => setTimeout(cb, 16));
  });

  afterEach(() => {
    jest.clearAllTimers();
  });

  describe('Basic Rendering', () => {
    it('renders without crashing', () => {
      render(<${componentName} />);
      expect(screen.getByRole('region')).toBeInTheDocument();
    });

    it('applies custom className and styles', () => {
      render(<${componentName} className="custom-class" width={800} height={600} />);
      const container = screen.getByRole('region');
      expect(container).toHaveClass('custom-class');
      expect(container).toHaveStyle({ width: '800px', height: '600px' });
    });
  });

  describe('Auto-Scroll Functionality', () => {
    it('starts scrolling when isPlaying is true', async () => {
      const { rerender } = render(<${componentName} isPlaying={false} />);
      
      rerender(<${componentName} isPlaying={true} currentTimeMs={1000} />);
      
      await waitFor(() => {
        expect(mockRequestAnimationFrame).toHaveBeenCalled();
      });
    });

    it('stops scrolling when isPlaying is false', async () => {
      const { rerender } = render(<${componentName} isPlaying={true} />);
      
      jest.clearAllMocks();
      rerender(<${componentName} isPlaying={false} />);
      
      // Should not trigger new animation frames
      await waitFor(() => {
        expect(mockRequestAnimationFrame).not.toHaveBeenCalled();
      }, { timeout: 100 });
    });

    it('updates scroll position based on currentTimeMs', async () => {
      const onSeek = jest.fn();
      render(<${componentName} isPlaying={true} currentTimeMs={5000} onSeek={onSeek} />);
      
      await waitFor(() => {
        // Should position scroll based on time (5000ms * 0.1 = 500px)
        const container = screen.getByRole('region');
        expect(container.querySelector('.tab-content')).toHaveStyle({
          transform: expect.stringContaining('translateY(-500px)')
        });
      });
    });
  });

  describe('User Interactions', () => {
    it('handles click to seek', async () => {
      const onSeek = jest.fn();
      render(<${componentName} onSeek={onSeek} />);
      
      const container = screen.getByRole('region');
      fireEvent.click(container, { clientY: 100 });
      
      expect(onSeek).toHaveBeenCalledWith(expect.any(Number));
    });

    it('handles manual scroll override', async () => {
      const onSeek = jest.fn();
      render(<${componentName} isPlaying={true} onSeek={onSeek} />);
      
      const container = screen.getByRole('region');
      fireEvent.scroll(container, { target: { scrollTop: 200 } });
      
      // Manual scroll should override auto-scroll temporarily
      await waitFor(() => {
        expect(onSeek).toHaveBeenCalled();
      });
    });
  });

  describe('Performance', () => {
    it('only renders visible notes for performance', () => {
      const largeTablature = Array.from({ length: 1000 }, (_, i) => ({
        timeMs: i * 100,
        string: Math.floor(Math.random() * 6),
        fret: Math.floor(Math.random() * 12)
      }));

      render(<${componentName} tablature={largeTablature} height={600} />);
      
      // Should only render notes within viewport + buffer
      const notes = screen.getAllByTestId('tab-note');
      expect(notes.length).toBeLessThan(100); // Much less than 1000
    });

    it('maintains 60fps animation performance', async () => {
      const timestamps: number[] = [];
      mockRequestAnimationFrame.mockImplementation((cb) => {
        const now = performance.now();
        timestamps.push(now);
        setTimeout(cb, 16); // 60fps = ~16ms
        return 1;
      });

      render(<${componentName} isPlaying={true} />);
      
      await waitFor(() => {
        expect(timestamps.length).toBeGreaterThan(5);
      });

      // Check that frame timing is consistent (~16ms intervals)
      const intervals = timestamps.slice(1).map((t, i) => t - timestamps[i]);
      const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
      expect(avgInterval).toBeCloseTo(16, 5); // Within 5ms of 16ms target
    });
  });

  describe('Edge Cases', () => {
    it('handles empty tablature gracefully', () => {
      render(<${componentName} tablature={[]} />);
      expect(screen.getByRole('region')).toBeInTheDocument();
      expect(screen.queryByTestId('tab-note')).not.toBeInTheDocument();
    });

    it('handles invalid time values', () => {
      render(<${componentName} currentTimeMs={-1000} />);
      expect(screen.getByRole('region')).toBeInTheDocument();
    });

    it('cleans up animation frame on unmount', () => {
      const cancelAnimationFrame = jest.fn();
      Object.defineProperty(window, 'cancelAnimationFrame', {
        value: cancelAnimationFrame,
        writable: true
      });

      const { unmount } = render(<${componentName} isPlaying={true} />);
      unmount();

      expect(cancelAnimationFrame).toHaveBeenCalled();
    });
  });
});`;
  }

  private generateHookTest(
    hookName: string,
    file: FileSpec,
    meta: any
  ): string {
    const sourceFile = file.path.replace(/\.test\.ts$/, ".ts");
    const relativePath = "./" + path.basename(sourceFile);

    return `/**
 * ${hookName} Hook Tests
 * Comprehensive hook testing with edge cases
 */
import { renderHook, act } from '@testing-library/react';
import { ${hookName} } from '${relativePath}';

// Mock performance.now and requestAnimationFrame
const mockPerformanceNow = jest.fn();
Object.defineProperty(window, 'performance', {
  value: { now: mockPerformanceNow },
  writable: true
});

describe('${hookName}', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    mockPerformanceNow.mockReturnValue(0);
  });

  it('initializes with default values', () => {
    const { result } = renderHook(() => ${hookName}());
    
    expect(result.current.state).toBeDefined();
    expect(result.current.isScrolling).toBe(false);
  });

  it('updates state when setTarget is called', () => {
    const { result } = renderHook(() => ${hookName}());
    
    act(() => {
      result.current.setTarget(100, 200);
    });

    expect(result.current.state.targetScrollX).toBe(100);
    expect(result.current.state.targetScrollY).toBe(200);
    expect(result.current.isScrolling).toBe(true);
  });

  it('respects boundary constraints', () => {
    const { result } = renderHook(() => ${hookName}({
      boundaries: { minX: 0, maxX: 500, minY: 0, maxY: 300 }
    }));
    
    act(() => {
      result.current.setTarget(1000, 500); // Beyond boundaries
    });

    expect(result.current.state.targetScrollX).toBeLessThanOrEqual(500);
    expect(result.current.state.targetScrollY).toBeLessThanOrEqual(300);
  });

  it('applies easing calculations correctly', () => {
    const { result } = renderHook(() => ${hookName}({ easing: true }));
    
    act(() => {
      result.current.setTarget(100);
      const state = result.current.tick(16); // 16ms frame
      expect(state.currentScrollX).toBeGreaterThan(0);
      expect(state.currentScrollX).toBeLessThan(100);
    });
  });
});`;
  }

  private generateUtilTest(
    utilName: string,
    file: FileSpec,
    meta: any
  ): string {
    const sourceFile = file.path.replace(/\.test\.ts$/, ".ts");
    const relativePath = "./" + path.basename(sourceFile);

    return `/**
 * ${utilName} Utility Tests
 * Comprehensive utility function testing
 */
import * as ${utilName} from '${relativePath}';

describe('${utilName}', () => {
  describe('core functionality', () => {
    it('exports expected functions', () => {
      expect(typeof ${utilName}).toBe('object');
      expect(Object.keys(${utilName}).length).toBeGreaterThan(0);
    });
  });

  describe('edge cases', () => {
    it('handles invalid inputs gracefully', () => {
      // Test with null, undefined, invalid values
      // Implementation depends on specific utility functions
      expect(true).toBe(true);
    });
  });
});`;
  }

  private generateAdvancedTypes(
    file: FileSpec,
    meta: any,
    context: SpecificationData
  ): string {
    const isScrolling = /scroll/i.test(file.path);
    const isNotation = /notation/i.test(file.path);
    const isGuitar = /guitar/i.test(file.path);

    if (isScrolling) {
      return this.generateScrollingTypes(file, meta);
    } else if (isNotation) {
      return this.generateNotationTypes(file, meta);
    } else if (isGuitar) {
      return this.generateGuitarTypes(file, meta);
    } else {
      return generateTypesTemplate(meta);
    }
  }

  private generateScrollingTypes(file: FileSpec, meta: any): string {
    return `/**
 * Scrolling Types - Advanced auto-scroll and viewport management
 * ${meta.description}
 */

// Core scroll state management
export interface AutoScrollState {
  isScrolling: boolean;
  currentScrollX: number;
  currentScrollY: number;
  targetScrollX: number;
  targetScrollY: number;
  scrollVelocity: number;
  lastFrameTime?: number;
}

// Configuration options for auto-scroll behavior
export interface AutoScrollOptions {
  velocity?: number;
  maxLookahead?: number;
  easing?: boolean;
  boundaries?: ScrollBoundaries;
  syncThreshold?: number;
}

// Boundary constraints for scrolling
export interface ScrollBoundaries {
  minX?: number;
  maxX?: number;
  minY?: number;
  maxY?: number;
}

// Viewport management
export interface ViewportState {
  width: number;
  height: number;
  scrollTop: number;
  scrollLeft: number;
  visibleStartMs: number;
  visibleEndMs: number;
  bufferStartMs: number;
  bufferEndMs: number;
}

export interface ViewportOptions {
  bufferMs?: number;
  pixelsPerMs?: number;
  minBufferSize?: number;
  maxBufferSize?: number;
}

// Scroll synchronization with audio
export interface ScrollSyncState {
  lastAudioTime: number;
  lastScrollTime: number;
  driftMs: number;
  correctionFactor: number;
  syncActive: boolean;
}

export interface ScrollSyncOptions {
  setTarget: (x: number, y?: number) => void;
  pixelsPerMs?: number;
  onTimeChange?: (timeMs: number) => void;
  driftThreshold?: number;
  correctionRate?: number;
}

// Animation frame management
export interface AnimationState {
  frameId?: number;
  lastFrameTime: number;
  deltaTime: number;
  fps: number;
  frameTimes: number[];
}

// Scroll events and callbacks
export type ScrollEventType = 'manual' | 'auto' | 'seek' | 'sync';

export interface ScrollEvent {
  type: ScrollEventType;
  position: { x: number; y: number };
  timeMs: number;
  source: 'user' | 'audio' | 'system';
}

export interface ScrollCallbacks {
  onScroll?: (event: ScrollEvent) => void;
  onSeek?: (timeMs: number) => void;
  onManualOverride?: () => void;
  onAutoResume?: () => void;
}

// Performance monitoring
export interface ScrollPerformanceMetrics {
  averageFps: number;
  frameDrops: number;
  memoryUsage?: number;
  renderTime: number;
  scrollLatency: number;
}

// Virtual rendering optimization
export interface VirtualRenderState {
  visibleItems: number;
  totalItems: number;
  renderWindow: { start: number; end: number };
  bufferSize: number;
}`;
  }

  private generateNotationTypes(file: FileSpec, meta: any): string {
    return `/**
 * Notation Types - Music staff and chord symbol parsing
 * ${meta.description}
 */

// Core notation elements
export interface NotationElement {
  type: NotationType;
  timeMs: number;
  durationMs?: number;
  position: NotationPosition;
  attributes?: NotationAttributes;
}

export type NotationType = 
  | 'note' 
  | 'rest' 
  | 'chord' 
  | 'clef' 
  | 'timeSig' 
  | 'keySig' 
  | 'technique';

export interface NotationPosition {
  measure: number;
  beat: number;
  tick: number;
  staff?: number;
  voice?: number;
}

export interface NotationAttributes {
  dynamics?: DynamicLevel;
  articulation?: Articulation[];
  ornaments?: Ornament[];
  expression?: string;
}

// Musical notes and pitches
export interface MusicalNote extends NotationElement {
  pitch: NotePitch;
  octave: number;
  accidental?: Accidental;
  tieStart?: boolean;
  tieEnd?: boolean;
  stem?: StemDirection;
}

export interface NotePitch {
  step: NoteStep;
  alter?: number; // semitone alteration
}

export type NoteStep = 'C' | 'D' | 'E' | 'F' | 'G' | 'A' | 'B';
export type Accidental = 'sharp' | 'flat' | 'natural' | 'double-sharp' | 'double-flat';
export type StemDirection = 'up' | 'down' | 'auto';

// Chord symbols and progressions
export interface ChordSymbol extends NotationElement {
  root: NoteStep;
  rootAccidental?: Accidental;
  quality: ChordQuality;
  extensions?: ChordExtension[];
  bass?: NotePitch;
  inversion?: number;
  symbol: string; // Original symbol text
}

export type ChordQuality = 
  | 'major' 
  | 'minor' 
  | 'dominant' 
  | 'diminished' 
  | 'augmented' 
  | 'suspended';

export interface ChordExtension {
  interval: number;
  accidental?: Accidental;
  add?: boolean;
}

// Guitar-specific techniques
export interface GuitarTechnique extends NotationElement {
  technique: TechniqueType;
  startFret?: number;
  endFret?: number;
  string?: number;
  intensity?: number;
  duration?: number;
}

export type TechniqueType = 
  | 'bend' 
  | 'slide' 
  | 'hammer' 
  | 'pull' 
  | 'vibrato' 
  | 'palm-mute' 
  | 'tap' 
  | 'harmonic';

// Rhythm and timing
export interface TimeSignature extends NotationElement {
  beats: number;
  beatType: number; // 1, 2, 4, 8, 16, etc.
  compound?: boolean;
  grouping?: number[];
}

export interface KeySignature extends NotationElement {
  key: NoteStep;
  mode: KeyMode;
  accidentals: Accidental[];
  fifths: number; // Circle of fifths position
}

export type KeyMode = 'major' | 'minor' | 'dorian' | 'mixolydian' | 'lydian';

// Dynamic and expression markings
export type DynamicLevel = 'ppp' | 'pp' | 'p' | 'mp' | 'mf' | 'f' | 'ff' | 'fff';
export type Articulation = 'staccato' | 'accent' | 'tenuto' | 'marcato' | 'fermata';
export type Ornament = 'trill' | 'turn' | 'mordent' | 'grace' | 'appoggiatura';

// Parsing results and metadata
export interface ParseResult<T = NotationElement> {
  success: boolean;
  elements: T[];
  errors: ParseError[];
  warnings: string[];
  metadata: ParseMetadata;
}

export interface ParseError {
  type: 'syntax' | 'semantic' | 'validation';
  message: string;
  position?: NotationPosition;
  severity: 'error' | 'warning' | 'info';
}

export interface ParseMetadata {
  format: NotationFormat;
  version?: string;
  title?: string;
  composer?: string;
  tempo?: number;
  timeSignature?: TimeSignature;
  keySignature?: KeySignature;
  measures: number;
  duration: number;
}

export type NotationFormat = 'musicxml' | 'guitarpro' | 'ascii-tab' | 'chord-chart' | 'abc';`;
  }

  private generateGuitarTypes(file: FileSpec, meta: any): string {
    return `/**
 * Guitar Types - Tablature and guitar-specific notation
 * ${meta.description}
 */

// Guitar tablature representation
export interface TabNote {
  timeMs: number;
  string: number; // 1-6 (1 = high E)
  fret: number; // 0-24
  technique?: GuitarTechnique;
  duration?: number;
  velocity?: number;
}

export interface TabMeasure {
  number: number;
  timeMs: number;
  durationMs: number;
  notes: TabNote[];
  chords?: TabChord[];
  timeSignature?: { beats: number; unit: number };
}

export interface TabChord {
  timeMs: number;
  frets: number[]; // Array of 6 fret positions, -1 for muted
  name?: string;
  duration?: number;
  technique?: GuitarTechnique;
}

// Guitar configuration
export interface GuitarConfig {
  strings: number;
  tuning: string[];
  frets: number;
  capo?: number;
  scale?: number; // Scale length in mm
}

export interface StringInfo {
  number: number;
  note: string;
  frequency: number;
  gauge?: string;
}

// Guitar techniques with parameters
export interface GuitarTechnique {
  type: TechniqueType;
  startFret?: number;
  endFret?: number;
  intensity?: number;
  speed?: number;
  direction?: 'up' | 'down';
}

export type TechniqueType = 
  | 'bend' 
  | 'slide' 
  | 'hammer-on' 
  | 'pull-off' 
  | 'vibrato' 
  | 'palm-mute' 
  | 'tap' 
  | 'natural-harmonic' 
  | 'artificial-harmonic'
  | 'pinch-harmonic'
  | 'tremolo-picking'
  | 'alternate-picking';

// Chord fingerings and patterns
export interface ChordFingering {
  name: string;
  frets: number[];
  fingers?: number[]; // 1-4 for fingers, 0 for open, -1 for muted
  barre?: { fret: number; strings: number[] };
  difficulty: 'beginner' | 'intermediate' | 'advanced';
  variations?: ChordFingering[];
}

export interface ChordProgression {
  chords: string[];
  pattern: string;
  key: string;
  tempo?: number;
  strumming?: StrummingPattern;
}

export interface StrummingPattern {
  pattern: string;
  beatsPerMeasure: number;
  emphasis?: number[];
}

// Display and rendering
export interface DisplayOptions {
  showFretNumbers: boolean;
  showStringNames: boolean;
  showChordNames: boolean;
  showTechniques: boolean;
  colorScheme: ColorScheme;
  fontSize: number;
}

export interface ColorScheme {
  background: string;
  strings: string;
  frets: string;
  notes: string;
  techniques: string;
  chords: string;
}`;
  }

  private generateAdvancedComponent(
    file: FileSpec,
    meta: any,
    context: SpecificationData
  ): string {
    const isScrolling = /scroll/i.test(file.path + file.description);
    const isTabDisplay = /tab|tablature/i.test(file.path + file.description);
    const isSVG = /svg/i.test(file.path + file.description);

    if (isScrolling && isTabDisplay) {
      return this.generateScrollingTabComponent(file, meta);
    } else if (isSVG && isTabDisplay) {
      return generateComponentTemplate({
        ...meta,
        flavor: "SVG_TABPLAYER_PRO",
      });
    } else {
      return generateComponentTemplate({
        ...meta,
        flavor: "STANDARD_COMPONENT",
      });
    }
  }

  private generateScrollingTabComponent(file: FileSpec, meta: any): string {
    const name = meta.componentName || this.extractComponentName(file.path);

    return `/**
 * ${name} - Advanced Scrolling Tablature Display
 * Features: 60fps auto-scroll, audio sync, viewport management
 */
import React, { useEffect, useRef, useState, useCallback } from "react";
import { useAutoScroll } from "../hooks/useAutoScroll";
import { usePlaybackSync } from "../hooks/usePlaybackSync";

export interface ${name}Props {
  width?: number;
  height?: number;
  tablature: TabNote[];
  isPlaying?: boolean;
  currentTimeMs?: number;
  scrollVelocity?: number;
  lookaheadMs?: number;
  onSeek?: (timeMs: number) => void;
}

export interface TabNote {
  timeMs: number;
  string: number;
  fret: number;
  technique?: string;
}

export interface ScrollState {
  currentY: number;
  targetY: number;
  velocity: number;
  isActive: boolean;
}

const ${name}: React.FC<${name}Props> = ({
  width = 800,
  height = 600,
  tablature = [],
  isPlaying = false,
  currentTimeMs = 0,
  scrollVelocity = 0.5,
  lookaheadMs = 2000,
  onSeek
}) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const [scrollState, setScrollState] = useState<ScrollState>({
    currentY: 0,
    targetY: 0,
    velocity: scrollVelocity,
    isActive: false
  });

  // Auto-scroll hook integration
  const autoScroll = useAutoScroll({
    velocity: scrollVelocity,
    maxLookahead: lookaheadMs,
    easing: true
  });

  // Playback synchronization
  const playbackSync = usePlaybackSync({
    setTarget: autoScroll.setTarget,
    pixelsPerMs: 0.1,
    onTimeChange: onSeek
  });

  // Update scroll position based on playback time
  useEffect(() => {
    if (isPlaying) {
      const targetY = currentTimeMs * 0.1; // pixels per ms
      autoScroll.setTarget(0, targetY);
      autoScroll.start();
    } else {
      autoScroll.stop();
    }
  }, [isPlaying, currentTimeMs, autoScroll]);

  // Animation frame loop for smooth scrolling
  useEffect(() => {
    let animationFrame: number;
    let lastTime = performance.now();

    const animate = (currentTime: number) => {
      const deltaTime = currentTime - lastTime;
      lastTime = currentTime;

      const newState = autoScroll.tick(deltaTime);
      setScrollState(newState);

      if (newState.isActive) {
        animationFrame = requestAnimationFrame(animate);
      }
    };

    if (scrollState.isActive) {
      animationFrame = requestAnimationFrame(animate);
    }

    return () => {
      if (animationFrame) {
        cancelAnimationFrame(animationFrame);
      }
    };
  }, [scrollState.isActive, autoScroll]);

  const handleContainerClick = useCallback((event: React.MouseEvent) => {
    const rect = containerRef.current?.getBoundingClientRect();
    if (!rect) return;

    const y = event.clientY - rect.top + scrollState.currentY;
    const timeMs = y / 0.1; // reverse pixels per ms calculation

    playbackSync.updateFromScroll(y);
    onSeek?.(timeMs);
  }, [scrollState.currentY, playbackSync, onSeek]);

  const visibleNotes = tablature.filter(note => {
    const noteY = note.timeMs * 0.1;
    return noteY >= scrollState.currentY - 100 && 
           noteY <= scrollState.currentY + height + 100;
  });

  return (
    <div
      ref={containerRef}
      className="scrolling-tab-display"
      style={{ 
        width, 
        height, 
        overflow: 'hidden',
        position: 'relative',
        backgroundColor: '#000',
        cursor: 'pointer'
      }}
      onClick={handleContainerClick}
    >
      <div
        className="tab-content"
        style={{
          transform: \`translateY(-\${scrollState.currentY}px)\`,
          transition: scrollState.isActive ? 'none' : 'transform 0.1s ease-out'
        }}
      >
        {/* String lines */}
        {[0, 1, 2, 3, 4, 5].map(stringIndex => (
          <div
            key={stringIndex}
            className="string-line"
            style={{
              position: 'absolute',
              top: 100 + stringIndex * 40,
              left: 0,
              width: '100%',
              height: 2,
              backgroundColor: '#666',
              zIndex: 1
            }}
          />
        ))}

        {/* Tab notes */}
        {visibleNotes.map((note, index) => (
          <div
            key={index}
            className="tab-note"
            style={{
              position: 'absolute',
              top: 85 + note.string * 40,
              left: 50,
              transform: \`translateY(\${note.timeMs * 0.1}px)\`,
              width: 30,
              height: 30,
              backgroundColor: '#e74c3c',
              color: 'white',
              borderRadius: '50%',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              fontSize: 12,
              fontWeight: 'bold',
              zIndex: 2
            }}
          >
            {note.fret}
          </div>
        ))}

        {/* Playback cursor */}
        <div
          className="playback-cursor"
          style={{
            position: 'absolute',
            top: 50,
            left: 0,
            width: '100%',
            height: 2,
            backgroundColor: '#3498db',
            transform: \`translateY(\${currentTimeMs * 0.1}px)\`,
            zIndex: 3
          }}
        />
      </div>
    </div>
  );
};

export default ${name};`;
  }

  private generateAdvancedHook(
    file: FileSpec,
    meta: any,
    context: SpecificationData
  ): string {
    const isAutoScroll = /autoscroll|scroll/i.test(file.path);
    const isAudio = /audio|engine/i.test(file.path);
    const isPlayback = /playback|sync/i.test(file.path);

    if (isAutoScroll) {
      return this.generateAutoScrollHook(file, meta);
    } else if (isAudio) {
      return generateHookTemplate({
        ...meta,
        nameHint: "useAudioEngine",
      });
    } else if (isPlayback) {
      return generateHookTemplate({
        ...meta,
        nameHint: "usePlaybackSync",
      });
    } else {
      return generateHookTemplate(meta);
    }
  }

  private generateAutoScrollHook(file: FileSpec, meta: any): string {
    const hookName = meta.componentName || "useAutoScroll";

    return `/**
 * ${hookName} - Advanced auto-scroll management with 60fps animation
 * Production-ready smooth scrolling with easing and boundary checks
 */
import { useCallback, useRef, useState, useEffect } from "react";

export interface AutoScrollState {
  isScrolling: boolean;
  currentScrollX: number;
  currentScrollY: number;
  targetScrollX: number;
  targetScrollY: number;
  scrollVelocity: number;
}

export interface AutoScrollOptions {
  velocity?: number;
  maxLookahead?: number;
  easing?: boolean;
  boundaries?: {
    minX?: number;
    maxX?: number;
    minY?: number;
    maxY?: number;
  };
}

export function ${hookName}(options: AutoScrollOptions = {}) {
  const {
    velocity = 0.35,
    maxLookahead = 600,
    easing = true,
    boundaries = {}
  } = options;

  const stateRef = useRef<AutoScrollState>({
    isScrolling: false,
    currentScrollX: 0,
    currentScrollY: 0,
    targetScrollX: 0,
    targetScrollY: 0,
    scrollVelocity: Math.max(0.1, velocity),
  });

  const [state, setState] = useState(stateRef.current);

  const setTarget = useCallback((x: number, y?: number) => {
    const current = stateRef.current;
    
    // Apply boundaries
    let targetX = Math.max(
      boundaries.minX ?? -Infinity,
      Math.min(boundaries.maxX ?? Infinity, x)
    );
    
    let targetY = y !== undefined ? Math.max(
      boundaries.minY ?? -Infinity,
      Math.min(boundaries.maxY ?? Infinity, y)
    ) : current.targetScrollY;

    // Apply lookahead limits
    targetX = Math.min(current.currentScrollX + maxLookahead, targetX);
    
    current.targetScrollX = targetX;
    current.targetScrollY = targetY;
    current.isScrolling = true;
    
    stateRef.current = current;
    setState({ ...current });
  }, [boundaries, maxLookahead]);

  const start = useCallback(() => {
    stateRef.current.isScrolling = true;
    setState({ ...stateRef.current });
  }, []);

  const stop = useCallback(() => {
    stateRef.current.isScrolling = false;
    setState({ ...stateRef.current });
  }, []);

  const jump = useCallback((x: number, y?: number) => {
    const current = stateRef.current;
    current.currentScrollX = Math.max(boundaries.minX ?? -Infinity, x);
    
    if (y !== undefined) {
      current.currentScrollY = Math.max(boundaries.minY ?? -Infinity, y);
    }
    
    current.targetScrollX = current.currentScrollX;
    current.targetScrollY = current.currentScrollY;
    current.isScrolling = false;
    
    stateRef.current = current;
    setState({ ...current });
  }, [boundaries]);

  const tick = useCallback((deltaTimeMs: number = 16) => {
    const current = stateRef.current;
    if (!current.isScrolling) return current;

    const diffX = current.targetScrollX - current.currentScrollX;
    const diffY = current.targetScrollY - current.currentScrollY;
    
    // Check if we've reached the target
    if (Math.abs(diffX) < 0.5 && Math.abs(diffY) < 0.5) {
      current.currentScrollX = current.targetScrollX;
      current.currentScrollY = current.targetScrollY;
      current.isScrolling = false;
    } else {
      const easingFactor = easing ? 0.1 : 1;
      const timeScale = deltaTimeMs / 16; // normalize to 60fps
      
      const stepX = diffX * easingFactor * current.scrollVelocity * timeScale;
      const stepY = diffY * easingFactor * current.scrollVelocity * timeScale;
      
      current.currentScrollX += stepX;
      current.currentScrollY += stepY;
      
      // Apply boundaries to current position
      current.currentScrollX = Math.max(
        boundaries.minX ?? -Infinity,
        Math.min(boundaries.maxX ?? Infinity, current.currentScrollX)
      );
      current.currentScrollY = Math.max(
        boundaries.minY ?? -Infinity,
        Math.min(boundaries.maxY ?? Infinity, current.currentScrollY)
      );
    }
    
    stateRef.current = current;
    setState({ ...current });
    return current;
  }, [easing, boundaries]);

  const setVelocity = useCallback((newVelocity: number) => {
    stateRef.current.scrollVelocity = Math.max(0.1, newVelocity);
  }, []);

  return {
    state,
    setTarget,
    start,
    stop,
    jump,
    tick,
    setVelocity,
    isScrolling: state.isScrolling,
    currentPosition: { x: state.currentScrollX, y: state.currentScrollY },
    targetPosition: { x: state.targetScrollX, y: state.targetScrollY },
  };
}`;
  }

  private generateAdvancedEngine(
    file: FileSpec,
    meta: any,
    context: SpecificationData
  ): string {
    return generateEngineTemplate({
      ...meta,
      features: {
        webAudio: true,
        toneHooks: true,
        workletReady: true,
        lowLatency: true,
        parameterAutomation: true,
      },
    });
  }

  private generateAdvancedParser(
    file: FileSpec,
    meta: any,
    context: SpecificationData
  ): string {
    const isNotation = /notation|staff|chord|musicxml|gp/i.test(
      file.path + file.description
    );

    return generateParserTemplate({
      ...meta,
      flavor: isNotation ? "MUSIC_NOTATION_PRO" : "GENERIC_PARSER",
    });
  }

  private generateAdvancedUtil(
    file: FileSpec,
    meta: any,
    context: SpecificationData
  ): string {
    const isMusic = /music|chord|note|tab/i.test(file.path + file.description);

    if (isMusic) {
      return this.generateMusicUtilities(file, meta);
    } else {
      return generateUtilTemplate(meta);
    }
  }

  private generateMusicUtilities(file: FileSpec, meta: any): string {
    const name = this.extractComponentName(file.path) + "Utils";

    return `/**
 * ${name} - Advanced Music Theory Utilities
 * ${meta.description}
 */

// Guitar tuning presets
export const TUNINGS = {
  standard: ['E4', 'B3', 'G3', 'D3', 'A2', 'E2'],
  dropD: ['E4', 'B3', 'G3', 'D3', 'A2', 'D2'],
  openG: ['D4', 'B3', 'G3', 'D3', 'G2', 'D2'],
  dadgad: ['D4', 'A3', 'G3', 'D3', 'A2', 'D2'],
} as const;

// Note to frequency conversion (A4 = 440Hz)
export function noteToFrequency(note: string): number {
  const noteMap: Record<string, number> = {
    'C': 0, 'C#': 1, 'Db': 1, 'D': 2, 'D#': 3, 'Eb': 3,
    'E': 4, 'F': 5, 'F#': 6, 'Gb': 6, 'G': 7, 'G#': 8,
    'Ab': 8, 'A': 9, 'A#': 10, 'Bb': 10, 'B': 11
  };
  
  const match = note.match(/^([A-G][#b]?)([0-9])$/);
  if (!match) return 440;
  
  const [, noteName, octaveStr] = match;
  const semitone = noteMap[noteName];
  const octave = parseInt(octaveStr);
  
  if (semitone === undefined) return 440;
  
  const midiNumber = (octave + 1) * 12 + semitone;
  return 440 * Math.pow(2, (midiNumber - 69) / 12);
}

// Calculate fret position for a note on a string
export function calculateFret(targetNote: string, stringNote: string): number | null {
  const targetFreq = noteToFrequency(targetNote);
  const stringFreq = noteToFrequency(stringNote);
  
  if (targetFreq <= stringFreq) return null;
  
  const fret = Math.round(12 * Math.log2(targetFreq / stringFreq));
  return fret <= 24 ? fret : null;
}

// Common chord fingerings
export function getChordFingering(chord: string, tuning: string[] = TUNINGS.standard): number[] {
  const chordMap: Record<string, number[]> = {
    'C': [0, 1, 0, 2, 3, -1],
    'D': [-1, -1, 0, 2, 3, 2],
    'E': [0, 2, 2, 1, 0, 0],
    'F': [1, 1, 3, 3, 2, 1],
    'G': [3, 2, 0, 0, 3, 3],
    'A': [-1, 0, 2, 2, 2, 0],
    'Am': [-1, 0, 2, 2, 1, 0],
    'Dm': [-1, -1, 0, 2, 3, 1],
    'Em': [0, 2, 2, 0, 0, 0],
  };
  
  return chordMap[chord] || new Array(tuning.length).fill(-1);
}

// Time signature analysis
export function analyzeTimeSignature(bpm: number, beats: number): { beats: number; unit: number; bpm: number } {
  const clampedBpm = Math.max(60, Math.min(200, bpm));
  
  let timeSignature = { beats: 4, unit: 4 };
  
  switch (beats) {
    case 2: timeSignature = { beats: 2, unit: 4 }; break;
    case 3: timeSignature = { beats: 3, unit: 4 }; break;
    case 6: timeSignature = { beats: 6, unit: 8 }; break;
    case 12: timeSignature = { beats: 12, unit: 8 }; break;
    default: timeSignature = { beats: beats <= 7 ? beats : 4, unit: 4 };
  }
  
  return { ...timeSignature, bpm: clampedBpm };
}

// Tablature utilities
export function formatTabNote(fret: number, technique?: string): string {
  let notation = fret.toString();
  
  switch (technique) {
    case 'bend': notation += 'b'; break;
    case 'slide': notation += '/'; break;
    case 'hammer': notation += 'h'; break;
    case 'pull': notation += 'p'; break;
    case 'vibrato': notation += '~'; break;
  }
  
  return notation;
}`;
  }

  // ================================================
  // UTILITY METHODS
  // ================================================
  private detectFileType(filePath: string): string {
    const lower = filePath.toLowerCase();

    // Test files
    if (lower.includes(".test.") || lower.includes(".spec.")) return "test";

    // Parsers
    if (lower.includes("parser") || lower.includes("parsing")) return "parser";

    // Engines and Audio
    if (
      lower.includes("engine") ||
      lower.includes("audio") ||
      lower.includes("worklet")
    )
      return "engine";

    // Hooks (must check before components since some components contain "use")
    if (
      lower.includes("hook") ||
      lower.includes("/hooks/") ||
      lower.startsWith("use")
    )
      return "hook";

    // Utilities
    if (
      lower.includes("util") ||
      lower.includes("helper") ||
      lower.includes("/utils/")
    )
      return "util";

    // Types
    if (
      (lower.includes("type") || lower.includes("/types/")) &&
      lower.endsWith(".ts")
    )
      return "types";

    // Data and Constants
    if (
      lower.includes("data") ||
      lower.includes("constant") ||
      lower.includes("/data/")
    )
      return "data";

    // Configuration
    if (lower.includes("config")) return "config";

    // Components (TSX files or component directories)
    if (
      lower.includes("component") ||
      lower.endsWith(".tsx") ||
      lower.includes("/components/")
    )
      return "component";

    // Modules
    if (lower.includes("module") || lower.includes("/modules/"))
      return "module";

    // Default based on extension
    if (lower.endsWith(".tsx")) return "component";
    if (lower.endsWith(".ts")) return "util";

    return "component";
  }

  private extractComponentName(filePath: string): string {
    const basename = path.basename(filePath, path.extname(filePath));
    // Remove .test, .spec suffixes
    const cleanName = basename.replace(/\.(test|spec)$/, "");
    return cleanName.charAt(0).toUpperCase() + cleanName.slice(1);
  }

  private detectFeatures(filePath: string, description: string): string[] {
    const text = (filePath + " " + description).toLowerCase();
    const features: string[] = [];

    if (/scroll|auto-scroll/i.test(text)) features.push("auto-scroll");
    if (/svg|vector/i.test(text)) features.push("svg");
    if (/audio|sound/i.test(text)) features.push("audio");
    if (/sync|synchron/i.test(text)) features.push("sync");
    if (/tab|tablature/i.test(text)) features.push("tablature");
    if (/notation|staff/i.test(text)) features.push("notation");
    if (/viewport|view/i.test(text)) features.push("viewport");
    if (/animation|animate/i.test(text)) features.push("animation");
    if (/virtual|render/i.test(text)) features.push("virtual-rendering");
    if (/test|spec/i.test(text)) features.push("testing");

    return features;
  }

  private detectDomain(filePath: string): string {
    const lower = filePath.toLowerCase();

    if (lower.includes("/guitar/")) return "guitar";
    if (lower.includes("/notation/")) return "notation";
    if (lower.includes("/audio/")) return "audio";
    if (lower.includes("/playback/")) return "playback";
    if (lower.includes("/display/")) return "display";
    if (lower.includes("/parsing/")) return "parsing";
    if (lower.includes("/engine/")) return "engine";

    return "general";
  }

  private detectSubdomain(filePath: string): string | null {
    const lower = filePath.toLowerCase();

    if (lower.includes("/display/")) return "display";
    if (lower.includes("/parsers/")) return "parsers";
    if (lower.includes("/controls/")) return "controls";
    if (lower.includes("/sync/")) return "sync";
    if (lower.includes("/animation/")) return "animation";
    if (lower.includes("/viewport/")) return "viewport";

    return null;
  }

  private generateModulePath(name: string): string {
    const type = this.detectFileType(name);
    const cleanName = name.replace(/[^a-zA-Z0-9]/g, "");

    // Default domain-aware paths
    const domain = this.detectDomain(name);
    const subdomain = this.detectSubdomain(name);

    let basePath = "";

    switch (type) {
      case "component":
        basePath =
          domain !== "general"
            ? `src/components/${domain}${subdomain ? `/${subdomain}` : ""}`
            : "src/components";
        return `${basePath}/${cleanName}.tsx`;

      case "hook":
        basePath =
          domain !== "general"
            ? `src/hooks/${domain}${subdomain ? `/${subdomain}` : ""}`
            : "src/hooks";
        return `${basePath}/${cleanName}.ts`;

      case "util":
        basePath = domain !== "general" ? `src/utils/${domain}` : "src/utils";
        return `${basePath}/${cleanName}.ts`;

      case "types":
        basePath = domain !== "general" ? `src/types/${domain}` : "src/types";
        return `${basePath}/${cleanName}.ts`;

      case "parser":
        basePath =
          domain !== "general" ? `src/${domain}/parsers` : "src/parsers";
        return `${basePath}/${cleanName}.ts`;

      case "engine":
        return `src/engines/${cleanName}.ts`;

      case "data":
        return `src/data/${cleanName}.ts`;

      case "config":
        return `src/config/${cleanName}.ts`;

      case "module":
        basePath =
          domain !== "general"
            ? `src/modules/${domain}${subdomain ? `/${subdomain}` : ""}`
            : "src/modules";
        return `${basePath}/${cleanName}.ts`;

      case "test":
        // Tests should be co-located with their source files
        const sourceType = this.detectFileType(
          name.replace(/\.(test|spec)/, "")
        );
        const sourcePath = this.generateModulePath(
          name.replace(/\.(test|spec)/, "")
        );
        return sourcePath.replace(
          /\.(ts|tsx)$/,
          `.test${sourcePath.endsWith(".tsx") ? ".tsx" : ".ts"}`
        );

      default:
        return `src/modules/${cleanName}.ts`;
    }
  }

  private analyzeDependencies(files: any[]): string[] {
    const deps: string[] = [];

    const hasAudio = files.some((f) =>
      /audio|engine|worklet/i.test(f.type || "")
    );
    const hasReact = files.some((f) => /component|hook/i.test(f.type || ""));

    if (hasAudio) deps.push("tone", "web-audio-api");
    if (hasReact) deps.push("react", "react-dom");

    return deps;
  }

  // ================================================
  // FILE MANAGEMENT
  // ================================================
  private async moveSpec(
    absPath: string,
    targetDir: "processed" | "failed"
  ): Promise<void> {
    const { inputFolder } = this.getInputFolders();
    const targetFolder = path.join(inputFolder, targetDir);

    await fs.promises.mkdir(targetFolder, { recursive: true });

    const basename = path.basename(absPath);
    const destPath = path.join(targetFolder, basename);

    const finalPath = fs.existsSync(destPath)
      ? path.join(targetFolder, `${Date.now()}-${basename}`)
      : destPath;

    await fs.promises.rename(absPath, finalPath);
    this.lastProcessedSpec = null;
  }

  private async performBrainLearning(
    action: string,
    success: boolean,
    metadata: any = {}
  ): Promise<void> {
    try {
      const brain = getBrainInterface();
      await brain?.learnFromAction(action, success ? "success" : "failure", {
        version: "hybrid-v1",
        handler: "MaestroGuitarModuleBuilder",
        ...metadata,
      });
    } catch (error) {
      console.log("Brain learning error:", error);
    }
  }

  // ================================================
  // RESULTS DISPLAY
  // ================================================
  private async displayBuildResults(result: BuildResult): Promise<void> {
    const panel = vscode.window.createWebviewPanel(
      "maestroGuitarBuildResults",
      "Maestro.ai Guitar Builder Results",
      vscode.ViewColumn.One,
      { enableScripts: true }
    );

    panel.webview.html = this.generateResultsHTML(result);
  }

  private generateResultsHTML(result: BuildResult): string {
    const isHybrid = result.mode === "hybrid";
    const filesCreated = result.files.length;
    const modulesBuilt = result.modules.length;
    const filesUpdated = result.updates || 0;
    const totalOperations = filesUpdated + filesCreated + modulesBuilt;

    const items = [...(result.files || []), ...(result.modules || [])];

    // Calculate specialized counts
    const svgCount = items.filter(
      (item) =>
        item.features?.includes("svg") ||
        /svg|tab/i.test(item.path || item.name || "")
    ).length;

    const audioCount = items.filter(
      (item) =>
        item.features?.includes("audio") ||
        /engine|worklet|audio/i.test(item.type || "")
    ).length;

    const scrollingCount = items.filter(
      (item) =>
        item.features?.includes("auto-scroll") ||
        /scroll/i.test(item.path || item.name || "")
    ).length;

    // File creation section
    const createdFilesSection =
      filesCreated > 0
        ? `
      <h2>üìÅ Created Additional Files</h2>
      <ul class="module-list">
        ${result.files
          .map(
            (file) => `
          <li class="module-item">
            <strong>${this.extractComponentName(file.path)}</strong>
            <span style="color: #666;">(.${file.type})</span>
            ${file.features?.includes("svg") ? '<span style="color: #3498db; font-weight: bold;">[SVG]</span>' : ""}
            ${file.type === "engine" ? '<span style="color: #e67e22; font-weight: bold;">[ENGINE]</span>' : ""}
            <br>${file.description || "Generated by Maestro.ai"}
            <br><small>Path: ${file.path}</small>
          </li>
        `
          )
          .join("")}
      </ul>
    `
        : "";

    // Modules section
    const modulesSection =
      modulesBuilt > 0
        ? `
      <h2>üèóÔ∏è Built Maestro.ai Modules</h2>
      <ul class="module-list">
        ${result.modules
          .map(
            (module) => `
          <li class="module-item">
            <strong>${module.name}</strong>
            <span style="color: #666;">(.${module.type})</span>
            <br>${module.description || "Generated module"}
            <br><small>Path: ${module.path}</small>
          </li>
        `
          )
          .join("")}
      </ul>
    `
        : "";

    const dependenciesSection =
      result.dependencies.length > 0
        ? `
      <div class="dependencies-section">
        <h3>üì¶ Install Dependencies</h3>
        <p><code>npm install ${result.dependencies.join(" ")}</code></p>
      </div>
    `
        : "";

    return `<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Maestro.ai Guitar Builder Results</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      padding: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: #333333;
      line-height: 1.6;
      min-height: 100vh;
    }
    .container {
      background: white;
      border-radius: 12px;
      padding: 30px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.1);
      max-width: 1000px;
      margin: 0 auto;
    }
    .header {
      color: #e74c3c;
      border-bottom: 3px solid #e74c3c;
      padding-bottom: 15px;
      margin-bottom: 25px;
      font-size: 24px;
      font-weight: bold;
    }
    .discovery-highlight {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 20px;
      border-radius: 12px;
      margin: 20px 0;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }
    .discovery-highlight h3 {
      color: white;
      margin-bottom: 15px;
    }
    .discovery-highlight p {
      margin: 8px 0;
      font-size: 16px;
    }
    .build-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 15px;
      margin: 25px 0;
    }
    .stat-box {
      padding: 20px;
      background: #f8f9fa;
      border: 2px solid #e9ecef;
      border-radius: 8px;
      text-align: center;
      transition: transform 0.2s ease;
    }
    .stat-box:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }
    .stat-box h3 {
      margin: 0;
      font-size: 28px;
      color: #e74c3c;
      font-weight: bold;
    }
    .stat-box p {
      margin: 8px 0 0 0;
      font-size: 13px;
      color: #666;
      font-weight: 500;
    }
    .module-list {
      list-style: none;
      padding: 0;
    }
    .module-item {
      padding: 15px;
      margin: 10px 0;
      background: #f8f9fa;
      border-left: 4px solid #e74c3c;
      border-radius: 6px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    .next-steps {
      background: linear-gradient(135deg, #74b9ff 0%, #0984e3 100%);
      color: white;
      border-radius: 12px;
      padding: 25px;
      margin: 25px 0;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }
    .next-steps h3 {
      color: white;
      margin-bottom: 15px;
    }
    .next-steps p {
      margin: 8px 0;
      font-size: 15px;
    }
    .dependencies-section {
      background: #fff3cd;
      border: 2px solid #ffeaa7;
      border-radius: 8px;
      padding: 18px;
      margin: 20px 0;
    }
    .dependencies-section code {
      background: #f1f3f4;
      padding: 8px 12px;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
      color: #e74c3c;
      font-weight: bold;
    }
    h1, h2, h3 { 
      color: #333333; 
      margin-top: 0;
    }
    .next-steps h3, .discovery-highlight h3 {
      color: white;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1 class="header">üé∏ Maestro.ai Guitar Builder Results - ${isHybrid ? "Hybrid Mode" : result.mode === "create-files" ? "File Creation" : "Module Building"}</h1>

    <div class="discovery-highlight">
      <h3>üéØ Build Summary</h3>
      <p><strong>Files Updated:</strong> ${filesUpdated} existing components enhanced</p>
      <p><strong>Files Created:</strong> ${filesCreated} new files generated</p>
      <p><strong>Modules Built:</strong> ${modulesBuilt} modules constructed</p>
      <p><strong>Total Operations:</strong> ${totalOperations} successful operations</p>
    </div>

    <div class="build-stats">
      <div class="stat-box">
        <h3>${filesUpdated}</h3>
        <p>Files Updated</p>
      </div>
      <div class="stat-box">
        <h3>${filesCreated}</h3>
        <p>Files Created</p>
      </div>
      <div class="stat-box">
        <h3>${modulesBuilt}</h3>
        <p>Modules Built</p>
      </div>
      <div class="stat-box">
        <h3>${svgCount}</h3>
        <p>SVG Components</p>
      </div>
      <div class="stat-box">
        <h3>${audioCount}</h3>
        <p>Audio Engines</p>
      </div>
      <div class="stat-box">
        <h3>${scrollingCount}</h3>
        <p>Scrolling Systems</p>
      </div>
    </div>

    ${createdFilesSection}
    ${modulesSection}
    ${dependenciesSection}

    <div class="next-steps">
      <h3>üöÄ Next Steps</h3>
      <p>1. ‚úÖ ${isHybrid ? "Hybrid operations" : result.mode} completed successfully</p>
      <p>2. Run project build and verify all imports resolve correctly</p>
      <p>3. Test ${filesUpdated > 0 ? "enhanced functionality in updated components" : ""}${filesCreated > 0 ? "new file integrations" : ""}${modulesBuilt > 0 ? "module functionality" : ""}</p>
      <p>4. Verify index.ts exports are properly updated</p>
      <p>5. Deploy to development environment for testing</p>
    </div>
  </div>
</body>
</html>`;
  }
}

// ================================================
// COMMAND EXPORTS - Single Entry Point
// ================================================
export async function maestroGuitarModuleBuilderHandler(): Promise<void> {
  try {
    const builder = new MaestroGuitarModuleBuilder();
    await builder.buildMaestroGuitarModules();
    vscode.window.showInformationMessage(
      "‚úÖ Maestro.ai hybrid processing completed successfully!"
    );
  } catch (error) {
    vscode.window.showErrorMessage(`‚ùå Maestro.ai builder failed: ${error}`);
    console.error("Handler error:", error);
  }
}

// Batch processing export
export async function runAllPhaseSpecs(): Promise<void> {
  const builder = new MaestroGuitarModuleBuilder();

  try {
    const { inputFolder } = (builder as any).getInputFolders();
    const specs = fs
      .readdirSync(inputFolder)
      .filter((f) => f.toLowerCase().endsWith(".md"));

    if (specs.length === 0) {
      vscode.window.showInformationMessage("No specification files found.");
      return;
    }

    let processed = 0;
    for (const spec of specs) {
      try {
        const specPath = path.join(inputFolder, spec);
        await builder.buildMaestroGuitarModules(specPath);
        processed++;
      } catch (error) {
        console.error(`Failed to process ${spec}:`, error);
      }
    }

    vscode.window.showInformationMessage(
      `‚úÖ Batch complete. Processed: ${processed}/${specs.length}`
    );
  } catch (error) {
    vscode.window.showErrorMessage(`‚ùå Batch processing failed: ${error}`);
  }
}
